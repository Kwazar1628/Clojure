Clojure — современный диалект Лиспа, язык программирования общего назначения с поддержкой разработки в интерактивном режиме, поощряющий функциональное программирование и упрощающий поддержку многопоточности. Clojure работает на платформах JVM и CLR. Clojure отличает философия «код как данные» (гомоиконность) и развитая система лисп-макросов.
Как и в любом другом Лиспе, синтаксис Clojure основан на S-выражениях, которые перед компиляцией транслируются синтаксическим анализатором в структуры данных. Синтаксический анализатор Clojure поддерживает, помимо обычных списков, синтаксис литералов для ассоциативных массивов, множеств и векторов, передавая затем все эти структуры данных компилятору. Иначе говоря, компилятор Clojure компилирует не только списковые структуры данных, но и напрямую поддерживает все указанные типы.

Хотя Clojure является расширением изначальной версии Lisp, он не совместим с Lisp’ом, то есть программа на любой из современных версий Lisp’а (за исключением, возможно, самых коротких, примитивных и, к тому же, специально подобранных примеров) либо вообще не пройдёт транслятор Clojure, либо будет выполняться неправильно. Отличия от распространённых версий Lisp’а приведены на сайте языка. Вот некоторые из них:

  - идентификаторы регистро-зависимы;
  - оригинальный синтаксис для литералов, векторов, отображений (maps), регулярных выражений, анонимных функций и ряда других синтаксических элементов;
  - утрачена многозначность значения nil (которое в Lisp обозначает и пустой указатель, и пустой список, и логическое значение «ложь») — оно означает только отсутствующее значение     (пустую ссылку, подобно null в Java), для прочих значений используется специфический синтаксис;
  - многие традиционные функции поменяли имена, например, car и cdr заменены на first и rest;
  - поддерживаются одноимённые функции с различными наборами аргументов;
  - отсутствуют макросы чтения (read macros), что лишает возможности изменять синтаксис языка;
  - часть оставшихся неизменными синтаксических элементов изменили смысл;
  - появилась поддержка «ленивых» коллекций.

ПРЕИМУЩЕСТВА

Clojure обладает рядом преимуществ перед другими языками программирования:

- язык ориентирован на работу с данными. Данные вынесены в основу концепции Clojure. У него есть все средства для работы с ними, а также удобная библиотека. Язык заменяет данными    классы, иерархии, объекты, что позволяет разработчику легко работать и писать на Clojure;

- Clojure – очень динамический язык программирования. У него есть возможность запускать команды в консоли и тут же просматривать результат, не затрачивая лишнего времени. Также      есть возможность горячей подмены кода, позволяющая не инициализировать программу заново при каждом изменении в коде;

- язык очень компактен. Например, размер кода, написанного на Clojure, будет от 3 до 10 раз меньше, чем у Java.

Несмотря на схожесть синтаксиса, Clojure отличается и от Common Lisp, и от Scheme. Некоторые отличия обусловлены тем, что язык разработан для платформы JVM, что накладывает некоторые ограничения на реализацию. Например, JVM не поддерживает оптимизацию хвостовых вызовов (tail call optimization, TCO), поэтому в язык были введены явные операторы loop и recur. Также важными определяющими факторами JVM-платформы являются:

- boxed integers — нет поддержки полного набора типов чисел (numeric tower), которые есть в Scheme и Common Lisp;
- система исключений как в Java (в Common Lisp используется сигнальный протокол);
- используется соглашение о вызовах как в Java.

Из явных отличий от Common Lisp можно отметить следующие:

- идентификаторы в Clojure регистрозависимы (case-sensitive);
- большая часть данных — неизменяемая;
- пользователь не может изменять синтаксис языка путем ввода собственных макросов в процедуре чтения кода (read macros);
- введен специальный синтаксис для литералов, векторов, отображений (maps), регулярных выражений, анонимных функций и т.д.;
- существует возможность связывания метаданных с переменными и функциями;
- можно реализовать функции с одним именем и разным набором аргументов;
- многие привычные вещи, такие как let, по синтаксису отличаются от их аналогов в Common Lisp и Scheme (при этом используется меньше скобок), например, let связывает данные        последовательно, аналогично let* в Scheme;
- вместо функций car и cdr используются функции first и rest;
- nil не равен пустому списку или другому набору данных (коллекции) — он всего лишь означает отсутствующее значение (аналог null в Java);
